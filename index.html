<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Jump & Vanish - Bulletproof Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1e272e; font-family: Arial, sans-serif; touch-action: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        #ui {
            position: absolute; top: 20px; left: 20px; color: white; 
            font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000;
            pointer-events: none; z-index: 5;
        }

        #legend {
            position: absolute; top: 60px; left: 20px; color: white; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; pointer-events: none;
        }

        #controls {
            position: absolute; bottom: 20px; width: 100%; height: 120px;
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
            pointer-events: none; z-index: 5;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(5px);
            border: 2px solid white; border-radius: 50%;
            width: 80px; height: 80px; color: white;
            pointer-events: auto; 
            display: flex; align-items: center; justify-content: center;
            font-size: 30px; user-select: none; -webkit-user-select: none;
        }
        .btn:active { background: rgba(255, 255, 255, 0.6); }

        .d-pad { display: flex; gap: 20px; }
        
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); color: white;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 10;
        }
        button.restart {
            padding: 15px 30px; font-size: 20px; background: #0fb9b1; color: white;
            border: none; border-radius: 5px; cursor: pointer; margin-top: 20px; transition: 0.2s;
        }
        button.restart:hover { background: #2bcbba; }
    </style>
</head>
<body>

    <div id="ui">H√∂he: <span id="score">0</span>m</div>
    
    <div id="legend">
        ‚¨ú Grau: Normal<br>
        üü© Gr√ºn: Beweglich<br>
        üü¶ Blau: Super-Jump<br>
        üü• Rot: T√ñDLICH!<br>
        üüß Orange: Verschwindet in 3s!
    </div>
    
    <div id="game-over">
        <h1 id="death-reason">Gefallen!</h1>
        <p>Deine erreichte H√∂he: <span id="final-score">0</span>m</p>
        <button class="restart" onclick="engine.resetGame()">Neu Starten</button>
    </div>

    <div id="controls">
        <div class="d-pad">
            <div class="btn" id="btn-left">‚¨ÖÔ∏è</div>
            <div class="btn" id="btn-right">‚û°Ô∏è</div>
        </div>
        <div class="btn" id="btn-jump">‚¨ÜÔ∏è</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        class GameEngine {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x1e272e, 0.03); 
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                this.scene.add(dirLight);

                this.gameObjects = [];
                this.player = null;
                this.keys = { left: false, right: false, jump: false };
                this.gravity = -0.015;
                this.gameOver = false;
                
                this.highestY = 0;
                this.nextSpawnY = 5; 

                this.initPlayer();
                this.initLevel();
                this.setupInputs();
                this.animate();
            }

            initPlayer() {
                const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const material = new THREE.MeshLambertMaterial({ color: 0xf1c40f }); 
                this.player = new THREE.Mesh(geometry, material);
                
                this.player.velocity = { x: 0, y: 0, z: 0 };
                this.player.onGround = false;
                this.player.position.y = 1; 
                
                this.scene.add(this.player);
            }

            initLevel() {
                // Die unzerst√∂rbare Start-Plattform
                this.createObject(0, -1, 10, 1, 'start');

                while (this.nextSpawnY < 30) {
                    this.spawnLevelSegment(this.nextSpawnY);
                    this.nextSpawnY += (3 + Math.random() * 2); 
                }
            }

            spawnLevelSegment(yHeight) {
                const x = (Math.random() * 10) - 5;
                const width = 2.5 + Math.random() * 1.5;
                const rand = Math.random();

                if (rand < 0.15) {
                    this.createObject(x, yHeight, width, 0.5, 'bounce');
                } else if (rand < 0.35) {
                    this.createObject(x, yHeight, width, 0.5, 'moving');
                } else {
                    this.createObject(x, yHeight, width, 0.5, 'normal');
                    
                    if (Math.random() < 0.3) {
                        const obsX = x + (Math.random() * width - width/2);
                        this.createObject(obsX, yHeight + 0.75, 1, 1, 'obstacle');
                    }
                }
            }

            createObject(x, y, w, h, type) {
                let color = 0xbdc3c7; 
                if (type === 'bounce') color = 0x3498db; 
                if (type === 'moving') color = 0x2ecc71; 
                if (type === 'obstacle') color = 0xe74c3c; 

                const geometry = new THREE.BoxGeometry(w, h, type === 'obstacle' ? 1 : 3);
                const material = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, 0);
                
                // Wir speichern genaue Ma√üe f√ºr die Mathe-Hitbox
                mesh.userData = {
                    type: type,
                    isTouched: false,
                    speed: type === 'moving' ? (Math.random() > 0.5 ? 0.05 : -0.05) : 0,
                    width: w,
                    height: h
                };

                this.scene.add(mesh);
                this.gameObjects.push(mesh);
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') this.keys.right = true;
                    if (e.code === 'Space' || e.code === 'ArrowUp') this.keys.jump = true;
                });
                window.addEventListener('keyup', (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') this.keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') this.keys.right = false;
                    if (e.code === 'Space' || e.code === 'ArrowUp') this.keys.jump = false;
                });

                const addTouch = (id, key) => {
                    const el = document.getElementById(id);
                    el.addEventListener('touchstart', (e) => { e.preventDefault(); this.keys[key] = true; });
                    el.addEventListener('touchend', (e) => { e.preventDefault(); this.keys[key] = false; });
                    el.addEventListener('mousedown', (e) => { this.keys[key] = true; });
                    el.addEventListener('mouseup', (e) => { this.keys[key] = false; });
                };
                addTouch('btn-left', 'left');
                addTouch('btn-right', 'right');
                addTouch('btn-jump', 'jump');

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            triggerVanish(obj) {
                if (obj.userData.type === 'obstacle' || obj.userData.type === 'start') return;

                obj.userData.isTouched = true;
                obj.material.color.setHex(0xe67e22); 
                
                setTimeout(() => {
                    this.scene.remove(obj);
                    this.gameObjects = this.gameObjects.filter(p => p !== obj);
                }, 3000);
            }

            updatePhysics() {
                if (this.gameOver) return;

                if (this.keys.left) this.player.position.x -= 0.15;
                if (this.keys.right) this.player.position.x += 0.15;

                if (this.keys.jump && this.player.onGround) {
                    this.player.velocity.y = 0.4;
                    this.player.onGround = false;
                }
                
                this.player.velocity.y += this.gravity;
                
                // LIMIT FALL SPEED: Sch√ºtzt vor dem Durchglitschen bei 120/144 Hz Monitoren
                if (this.player.velocity.y < -0.6) this.player.velocity.y = -0.6;

                this.player.position.y += this.player.velocity.y;
                this.player.onGround = false;

                // PURE MATHEMATIK F√úR DIE KOLLISION (100% Sicher)
                const pX = this.player.position.x;
                const pY = this.player.position.y;
                const pBottom = pY - 0.4; // Spielerh√∂he ist 0.8 -> H√§lfte ist 0.4
                const pTop = pY + 0.4;
                const pLeft = pX - 0.3;   // Minimal kleiner als echte Breite (0.4) f√ºr saubere Kanten
                const pRight = pX + 0.3;

                for (let i = this.gameObjects.length - 1; i >= 0; i--) {
                    const obj = this.gameObjects[i];
                    
                    if (obj.userData.type === 'moving') {
                        obj.position.x += obj.userData.speed;
                        if (obj.position.x > 6 || obj.position.x < -6) obj.userData.speed *= -1;
                    }

                    const oX = obj.position.x;
                    const oY = obj.position.y;
                    const oW = obj.userData.width;
                    const oH = obj.userData.height;
                    
                    const oTop = oY + oH / 2;
                    const oBottom = oY - oH / 2;
                    const oLeft = oX - oW / 2;
                    const oRight = oX + oW / 2;

                    // Rote Hindernisse (direkter Tod bei Ber√ºhrung)
                    if (obj.userData.type === 'obstacle') {
                        if (pRight > oLeft && pLeft < oRight && pBottom < oTop && pTop > oBottom) {
                            this.endGame("In ein Hindernis gelaufen!");
                            return;
                        }
                        continue; 
                    }

                    // Normale Plattformen (Landen)
                    if (pRight > oLeft && pLeft < oRight) {
                        // Nur kollidieren, wenn man nach unten f√§llt
                        if (this.player.velocity.y <= 0) {
                            // Wenn die F√º√üe die Oberkante ber√ºhren oder maximal 0.6 Einheiten darunter sind
                            if (pBottom <= oTop && pBottom >= oBottom - 0.6) {
                                this.player.velocity.y = 0;
                                this.player.position.y = oTop + 0.4; 
                                this.player.onGround = true;

                                if (obj.userData.type === 'bounce') {
                                    this.player.velocity.y = 0.6; 
                                    this.player.onGround = false;
                                }

                                if (!obj.userData.isTouched) {
                                    this.triggerVanish(obj);
                                }
                            }
                        }
                    }
                }

                // Score und Endlos-Spawning
                if (this.player.position.y > this.highestY) {
                    this.highestY = this.player.position.y;
                    document.getElementById('score').innerText = Math.floor(this.highestY);
                }

                while (this.camera.position.y + 30 > this.nextSpawnY) {
                    this.spawnLevelSegment(this.nextSpawnY);
                    this.nextSpawnY += (3 + Math.random() * 2); 
                }

                const targetY = Math.max(2, this.highestY + 2); 
                this.camera.position.y += (targetY - this.camera.position.y) * 0.1;
                this.camera.position.x = 0;
                this.camera.position.z = 12;
                this.camera.lookAt(0, this.camera.position.y - 2, 0);

                if (this.player.position.y < this.camera.position.y - 12) {
                    this.endGame("Runtergefallen!");
                }
            }

            endGame(reason) {
                this.gameOver = true;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('death-reason').innerText = reason;
                document.getElementById('final-score').innerText = Math.floor(this.highestY);
            }

            resetGame() {
                this.gameObjects.forEach(obj => this.scene.remove(obj));
                this.gameObjects = [];
                
                this.player.position.set(0, 1, 0);
                this.player.velocity.y = 0;
                this.highestY = 0;
                this.nextSpawnY = 5;
                this.gameOver = false;
                
                document.getElementById('game-over').style.display = 'none';
                document.getElementById('score').innerText = '0';
                this.camera.position.set(0, 2, 12);
                
                this.initLevel();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updatePhysics();
                this.renderer.render(this.scene, this.camera);
            }
        }

        window.engine = new GameEngine();
    </script>
</body>
</html>
